// 给定 n 组询问，每组询问给定两个整数 a，b，请你输出 Cbamod(109+7) 的值。

// 输入格式
// 第一行包含整数 n。

// 接下来 n 行，每行包含一组 a 和 b。

// 输出格式
// 共 n 行，每行输出一个询问的解。

// 数据范围
// 1≤n≤10000,
// 1≤b≤a≤2000
// 输入样例：
// 3
// 3 1
// 5 3
// 2 2
// 输出样例：
// 3
// 10
// 1

// 如果用暴力算法，有10000对数，每个数在1-2000，最坏的情况是要进行 10000 * 2000 * 2000 = 4e10，肯定会超时
// 所以采用预处理的方式，使用公式 C(b)(a) = C(b)(a-1) + C(b-1)(a-1)
// 可以使用选苹果的方式理解，在a个苹果中选b个，假设先选了一个，如果这个苹果在选中的里面，那么剩余有C(b-1)(a-1)种情况，否则会有C(b)(a-1)中情况
#include<iostream>
using namespace std;

const int N = 2010, mod = 1e9 + 7;
int c[N][N];

void init(){
    for(int i = 0; i < N; i++)
        for(int j = 0; j <= i; j++)
            if(!j) c[i][j] = 1; // 特别的，如果在i个苹果里面选0个苹果，只有一种方式，这也是这种预处理算法的边界情况
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}

int main(){
    init();
    
    int n;
    cin >> n;
    while(n--){
        int a, b;
        cin >> a >> b;
        cout << c[a][b] << endl;
    }
    return 0;
}