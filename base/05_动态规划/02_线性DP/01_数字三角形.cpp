// 给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

//         7
//       3   8
//     8   1   0
//   2   7   4   4
// 4   5   2   6   5
// 输入格式
// 第一行包含整数 n，表示数字三角形的层数。

// 接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

// 输出格式
// 输出一个整数，表示最大的路径数字和。

// 数据范围
// 1≤n≤500,
// −10000≤三角形中的整数≤10000
// 输入样例：
// 5
// 7
// 3 8
// 8 1 0 
// 2 7 4 4
// 4 5 2 6 5
// 输出样例：
// 30

/*
思路呢很简单，就是现用a这个二维数组来保存数据，然后用f数组来保存从第一个数据到当前数据的最大值，比如说f[i][j]是由f[i-1][j-1]和f[i-1][j]这两个元素中
较大的那个加上a[i][j]组成的结果，需要注意的就是边界问题了
*/
#include<iostream>
using namespace std;

const int N = 510, INF = 1e9;
int a[N][N], f[N][N];

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) // 从控制台保存数据
        for(int j = 1; j <= i; j++)
            cin >> a[i][j];
    for(int i = 0; i <= n; i++) // 先把f数组都重置为负无穷大，因为如果a数组中有负值，此时如果实在边界，那么它只有一种选法，设置最小值就是为了方便处理边界
        for(int j = 0; j <= i + 1; j++) 
            f[i][j] = -INF;
    f[1][1] = a[1][1];
    for(int i = 2; i <= n; i++)
        for(int j = 1; j <= i; j++)
            f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j];
    int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res << endl;
    return 0;
}