// 给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。

// 对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

// 每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

// 输入格式
// 第一行包含两个整数 n 和 m。

// 接下来 n 行，每行包含一个字符串，表示给定的字符串。

// 再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。

// 字符串中只包含小写字母，且长度均不超过 10。

// 输出格式
// 输出共 m 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。

// 数据范围
// 1≤n,m≤1000,

// 输入样例：
// 3 2
// abc
// acd
// bcd
// ab 1
// acbd 2
// 输出样例：
// 1
// 3

/*
这道题跟最短编辑距离差不多，只不过要进行多次操作，最短编辑距离的时间复杂度是O(n^2)，而这里的字符串长度不超过10，所以就是10^10=100，而给出的给出的字符串
和要判断是否在修改范围内的字符串不超过1000，所以就是1000^1000=10^6，在乘上100就是10^8，C++一秒能执行 10^7 ~ 10^8，而题目给定的时间是2秒，所以可以ac
*/
#include<iostream>
#include<string.h>
using namespace std;

const int N = 1010, M = 15; // N是用来接收给定字符串的数量，M是接收字符串的最大长度
char str[N][M]; // 这个是被判定的字符串
int f[M][M];

int edit_distance(char a[], char b[]){
    int la = strlen(a + 1), lb = strlen(b + 1); // 获取两个字符串长度，因为都是从下标为1开始存储，所以是a+1和b+1
    // 剩下的就和最短编辑距离没差了
    for(int i = 0; i <= la; i++) f[i][0] = i;
    for(int i = 0; i <= lb; i++) f[0][i] = i;
    for(int i = 1; i <= la; i++)
        for(int j = 1; j <= lb; j++){
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j]));
        }
    
    return f[la][lb];
} 

int main(){
    int n, m;
    cin >> n >> m;
    for(int i = 0; i < n; i++) cin >> str[i] + 1; // 字符串都从下标为1开始存储
    while(m--){
        char s[M];
        int limit, res = 0;
        cin >> s + 1 >> limit;
        for(int i = 0; i < n; i++)
            if(edit_distance(str[i], s) <= limit)
                res++;
        cout << res << endl;
    }
    
    return 0;
}