// 给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

// 删除–将字符串 A 中的某个字符删除。
// 插入–在字符串 A 的某个位置插入某个字符。
// 替换–将字符串 A 中的某个字符替换为另一个字符。
// 现在请你求出，将 A 变为 B 至少需要进行多少次操作。

// 输入格式
// 第一行包含整数 n，表示字符串 A 的长度。

// 第二行包含一个长度为 n 的字符串 A。

// 第三行包含整数 m，表示字符串 B 的长度。

// 第四行包含一个长度为 m 的字符串 B。

// 字符串中均只包含大小写字母。

// 输出格式
// 输出一个整数，表示最少操作次数。

// 数据范围
// 1≤n,m≤1000
// 输入样例：
// 10 
// AGTCTGACGC
// 11 
// AGTAAGTAGGC
// 输出样例：
// 4

/*
状态表示f[i][j]
  集合：所有将a[1~i]变成b[1~j]所需要进行的最小操作步数
  属性：Min
状态计算：
  有三种操作方式，增删改
  删：如果要让第一个字符串的前i个字符与第二个字符串的前j个字符相同，使用删除方式，那么首先得保证第一个字符串前i-1个字符与第二个字符串前j个字母相同，
      也就可以表示成f[i][j] = f[i-1][j] + 1，因为只有保证了前i-1个字符匹配，此时删除最后一个字母才可以保证了他们可以匹配
  增：与删是对立的，如果要让第一个字符串的前i个字符与第二个字符串的前j个字符相同，使用增加方式，那么首先得保证第一个字符串的前i个字符与第二个字符串的前
      j-1个字符相同，这样增加了一个字符与b[j]匹配，就是的这两个字符串相同了，也就是f[i][j] = f[i][j - 1] + 1
  改：要改变第一个字符串的第i个字符，使得与第二个字符串的第j个字符相同，首先要保证a[1~i-1]和b[1~j-1]是相同的，此时才能比较a[i]和b[j]，如果相同就不同改变，
      如果不同就要改变，所以可以表示成 f[i][j] = f[i-1][j-1] + 1/0
使用这种方法要先确定边界情况，就是要使得a的前i个字符与b的第0个字符匹配，那么必须要进行i步删除操作，使得这i个字符都删掉才能保证相同，相同的，要使得a的第
0个字符与b的前j个字符匹配，也得把b字符串删掉j个字符，保证他们相同

f是二维数组，时间复杂度是O(n^2)，增删改三步操作，所以就是3n^2，所以最终的时间复杂度就是O(n^2)
*/
#include<iostream>
using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main(){
    cin >> n >> a + 1 >> m >> b + 1; // a和b数组都从1开始读入，因为要确定边界情况，会有i-1，如果从0开始会有多余的判断操作，这么做更方便
    // 下面这两步就是在a字符串匹配b字符串前0个字符要进行的次数，b字符串要匹配a字符串前0个字符要进行的次数，也就是确定边界情况
    for(int i = 0; i <= m; i++) f[0][i] = i;
    for(int i = 0; i <= n; i++) f[i][0] = i;
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); // 现在增和删而这种取较小值
            if(a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); // 然后比较a的第i个字符与b的第j个字符是否相同，相同就要加1，否则直接与
            else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); // f[i-1][j-1]相同
        }
    cout << f[n][m] << endl; // 最终这个输出就表示将a的前n个字符变成b的前m个字符所要进行的操作的最小值
    
    return 0;
}