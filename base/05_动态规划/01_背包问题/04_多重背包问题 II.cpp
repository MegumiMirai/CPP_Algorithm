// 有 N 种物品和一个容量是 V 的背包。

// 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

// 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
// 输出最大价值。

// 输入格式
// 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

// 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

// 输出格式
// 输出一个整数，表示最大价值。

// 数据范围
// 0<N≤1000
// 0<V≤2000
// 0<vi,wi,si≤2000
// 提示：
// 本题考查多重背包的二进制优化方法。

// 输入样例
// 4 5
// 1 2 3
// 2 4 1
// 3 4 3
// 4 5 2
// 输出样例：
// 10

/*
这道题在n、m、s这三方面都加强的了，首先确定的一点是，如果使用暴力做法，那么时间复杂度就是 1000 * 2000 * 2000 = 4e9，必然会TLE
我们先按照完全背包问题的思考方式
完全背包: f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, ... , f[i-1][j-kv] + kw)
         f[i][j-v] = max(         f[i-1][j-v],     f[i-1][j-2v] + w), ... , f[i-1][j-kv] + kw)
         所以f[i][j] = max(f[i][j], f[i][j-v] + w)
多重背包：f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, ... , f[i-1][j-kv] + kw)
         f[i][j-v] = max(         f[i-1][j-v],     f[i-1][j-2v] + w), ... , f[i-1][j-kv] + (k-1)w, f[i-1][j-(k+1)v + kw])
         此时是不可以按照完全背包那样做的，因为f[i][j-v]的最大值还包括了f[i-1][j-(k+1)v + kw]，但是是不需要它的，所以要另辟蹊径
备注：为什么完全背包问题没有f[i-1][j-(k+1)v + kw]，而多重背包有呢？答案是完全背包是没有显示第i个物品的个数，也就是没有s[i]，它可以一直装到背包满为止，
      而多重背包是有一定限制的，它不能多于s[i]，所以完全背包的末尾可以对齐

方法：二进制优化
我们可以这么做，每个物品有s个，那么我们可以把它分成k组，有1,2,4,8,16...,2^k,c，使得c = s - 2^k, 2^k <= s，并且 2^(k+1) > s，
那么所有数量都可以用这k组表示出来，比如说
通过第一组可以表示出 0-1，把第一组表示的范围加上第二组，得到2-3，那么把它们拼接就可以得到0-3
然后在加上第三组，得到4-7，与上面的拼接得到0-7
以此类推可以得到0-s
按照这种方式，可以把 n * m * s 优化成 n * m * log(s)，也就是 1000 * 2000 * log(2000) = 1e7，是在范围之内的
然后把这n个物品拆分之后可以得到 1000 * log2000 = 11000-12000个物品，如果用二维数组会开12010 * 2010大小的数组，太大了
所以我们可以选择直接使用一维数组来存储，然后按照01背包问题来做
*/
#include<iostream>
using namespace std;

const int N = 12010, M = 2010;
int v[N], w[N], f[M]; // v数组保存每个物品的体积，w数组保存每个物品的价值，f数组用来保存容积为j的时候的最优解

int main(){
    int n, m;
    cin >> n >> m;
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){ // 不断把s拆分，直到2^(k+1) > 为止 
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if(s > 0){ // 如果此时s还有，就把剩余的都存进去
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    // 后面就按照01背包问题来做，同样的，j也是要从m往v[i]遍历
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    
    return 0;
}