// 给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。

// 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

// 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

// 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

// 下面给出一个矩阵作为例子：

//  1  2  3  4 5

// 16 17 18 19 6

// 15 24 25 20 7

// 14 23 22 21 8

// 13 12 11 10 9
// 在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

// 在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。

// 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

// 输入格式
// 第一行包含两个整数 R 和 C。

// 接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。

// 输出格式
// 输出一个整数，表示可完成的最长滑雪长度。

// 数据范围
// 1≤R,C≤300,
// 0≤矩阵中整数≤10000
// 输入样例：
// 5 5
// 1 2 3 4 5
// 16 17 18 19 6
// 15 24 25 20 7
// 14 23 22 21 8
// 13 12 11 10 9
// 输出样例：
// 25


/*
状态表示：f[i,j]
  集合：所有从点(i, j)开始滑的最长路径
  属性：Max
状态计算：
  四个方向，f[i,j] = max(f[i][j + 1], f[i][j - 1], f[i - 1][j], f[i + 1][j]) + 1

使用记忆化搜索，也就是使用递归，代码复杂度会更小，比循环更容易理解，而且有的题用循环很难做出来，而使用记忆化可以很快做出来，而且用的时间可能会更少，
但是可能会有溢栈的风险
*/
#include<iostream>
#include<cstring>
using namespace std;

const int N = 310;

int n, m;
int h[N][N]; // 这个是用来记录每个点的高度
int f[N][N]; // 这个是用来记录从这个点开始能滑的最远长度

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1}; // 模拟上下左右四个方向

int dp(int x, int y){
    
    int &v = f[x][y]; // &在这里的作用是 之后出现的v都代表f[x][y]
    if(v != -1) return v; // 如果这个点的最长路径已经得到了，直接返回
    
    v = 1; // 先把自己算进去
    for(int i = 0; i < 4; i++){
        int a = x + dx[i], b = y + dy[i]; // 模拟四个防线
        if(a >= 1 && a <= n && b >= 1 && b <= m && h[a][b] < h[x][y]) // 如果这个点还在矩形中，并且高度更低
            v = max(v, dp(a, b) + 1); // 就从这四个方向中获取最大值
    }
    
    return v;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> h[i][j]; // 从控制台读取每个点的高度
            
    memset(f, -1, sizeof f); // 将每个点的最远长度都设置成-1，表示这个地方还没有更新过
    
    int res = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            res = max(res, dp(i, j)); // 获取最大值
            
    cout << res << endl;
    
    return 0;
}