// 给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

// 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

// 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

// 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。

// 输入格式
// 第一行包含两个整数 n 和 m。

// 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

// 输出格式
// 输出一个整数，表示从左上角移动至右下角的最少移动次数。

// 数据范围
// 1≤n,m≤100
// 输入样例：
// 5 5
// 0 1 0 0 0
// 0 1 0 1 0
// 0 0 0 0 0
// 0 1 1 1 0
// 0 0 0 1 0
// 输出样例：
// 8

#include<cstring>
#include<iostream>
using namespace std;

typedef pair<int, int> PII;
const int N = 101;
int n, m;
int g[N][N], d[N][N]; // g数组记录迷宫，d数组记录走到那里要多少步
PII q[N * N]; // 队列


int bfs(){
  int hh = 0, tt = 0;
  q[0] = {0, 0}; // 把{0， 0}保存到队列的第一个

  memset(d, -1, sizeof d); // 将d数组中所有元素重置为-1，表明还没有到这里
  d[0][0] = 0; // 起点到起点距离是0

  int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, -1, 0, 1 }; // 用这个来模拟上下左右
  
  while(hh <= tt){
    auto t = q[hh++]; 
    for(int i = 0; i < 4; i++){
      int x = t.first + dx[i], y = t.second + dy[i];
      if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1){ // 如果这里满足条件，就说明可以走这里，并且入队列
        d[x][y] = d[t.first][t.second] + 1;
        q[++tt] = { x, y };
      }
    }
  }
  return d[n - 1][m - 1];
}

int main(){
  cin >> n >> m;
  for(int i = 0; i < n; i++)
    for(int j = 0; j < m; j++)
      cin >> g[i][j];

  cout << bfs() << endl;

  return 0;
}