// 你玩过“拉灯”游戏吗？

// 25 盏灯排成一个 5×5 的方形。

// 每一个灯都有一个开关，游戏者可以改变它的状态。

// 每一步，游戏者可以改变某一个灯的状态。

// 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

// 我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。

// 下面这种状态

// 10111
// 01101
// 10111
// 10000
// 11011
// 在改变了最左上角的灯的状态后将变成：

// 01111
// 11101
// 10111
// 10000
// 11011
// 再改变它正中间的灯后状态将变成：

// 01111
// 11001
// 11001
// 10100
// 11011
// 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

// 输入格式
// 第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。

// 以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。

// 每组数据描述了一个游戏的初始状态。

// 各组数据间用一个空行分隔。

// 输出格式
// 一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

// 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。

// 数据范围
// 0<n≤500
// 输入样例：
// 3
// 00111
// 01011
// 10001
// 11010
// 11100

// 11101
// 11101
// 11110
// 11111
// 11111

// 01111
// 11111
// 11111
// 11111
// 11111
// 输出样例：

// 3
// 2
// -1

/*
思路：
  第一行一共有5格，枚举每个格子是否按，有2^5=32种方法，枚举这32种方案，然后从第二行开始，枚举这五个格子，如果当前格子上面的那个格子是暗的，就点亮当前格子
  从第2行到第n行都按照这个操作，最终查看最后一行是否都是亮着的，如果有暗的，就说明这种方案是不成立的，然后去枚举下一种方案；但是，如果最后一行都是亮的，
  那么就查看所需要的按的次数是否满足条件，满足就先将他与当前需要最少次数比较，保存较小者，直到所有方案都已经枚举完了
*/
#include<iostream>
#include<cstring>
using namespace std;

const int N = 6;
char g[N][N], backup[N][N]; // g是用来保存初始状态，backup是g的备份，后面所有的方案都在这上面进行
int dx[5] = { -1, 0, 1, 0, 0}, dy[5] = { 0, -1, 0, 1, 0}; // 这个是枚举如果点亮当前格子后要改变得地方

void turn(int x, int y){ // 改变第x行第y列，所有当前位置和上下左右都要改变
    for(int i = 0; i < 5; i++){
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= 5 || b < 0 || b >= 5) continue; // 如果超出了范围，就进行下一次循环
        backup[a][b] ^= 1; // 字符'1'的ASC码是49，二进制表示是110001，异或1之后是110000，也就是'0'，而'0'ASC码是48，二进制是110000，异或1后是'1'
    }
}

int main(){
    int n;
    cin >> n;
    while(n--){
        for(int i = 0; i < 5; i++) cin >> g[i]; // 从控制台读取每一行
        
        int res = 10; // res保存所需要的最小次数
        for(int op = 0; op < 32; op++){ // 枚举第一行每个格子是否改变的方案
            memcpy(backup, g, sizeof g); // 先把g复制到backup中，后续操作都是在backup中进行的
            int step = 0; // 步数
            for(int i = 0; i < 5; i++) // 枚举这一种方案的五个格子
                if(op >> i & 1){ // 如果它是1，就改变
                    step++; // 次数增加
                    turn(0, i); // 然后它和上下左右同时都改变
                }
            for(int i = 0; i < 4; i++) // 这个是枚举第一行到第n-1行
                for(int j = 0; j < 5; j++) // 枚举每个格子
                    if(backup[i][j] == '0'){ // 如果它是暗的
                        step++; // 次数增加
                        turn(i + 1, j); // 因为此时改变只能是第2行到第n行，所以是i+1
                    }
                    
            bool dark = false; // 定义变量判断最后一行是否有灯是暗的
            for(int i = 0; i < 5; i++)
                if(backup[4][i] == '0'){ // 如果是暗的，就直接退出循环
                    dark = true;
                    break;
                }
            
            if(!dark) res = min(res, step); // 如果没有暗的，就将它与res取较小值，表示这是一种可行方案
        }
        if(res > 6) res = -1; // 题目要求次数不能超过6，所以如果超过6，就把res置为-1，表示没有小于6步的方案
        
        cout << res << endl;
    }
    
    return 0;
}