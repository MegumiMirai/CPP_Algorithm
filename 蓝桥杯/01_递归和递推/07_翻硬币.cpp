// 小明正在玩一个“翻硬币”的游戏。

// 桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

// 比如，可能情形是：**oo***oooo

// 如果同时翻转左边的两个硬币，则变为：oooo***oooo

// 现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

// 我们约定：把翻动相邻的两个硬币叫做一步操作。

// 输入格式
// 两行等长的字符串，分别表示初始状态和要达到的目标状态。

// 输出格式
// 一个整数，表示最小操作步数

// 数据范围
// 输入字符串的长度均不超过100。
// 数据保证答案一定有解。

// 输入样例1：
// **********
// o****o****
// 输出样例1：
// 5
// 输入样例2：
// *o**o***o***
// *o***o**o***
// 输出样例2：
// 1

// 题目虽然说要最优解，而且保证是有解的，但是可以推出来只有一个解，所以只需要求出方案就可以了
// 从左往右遍历，如果start和end在下标为i的地方不一样，就让下标为i和i+1改变，直到最后，记录需要的步数
#include<iostream>
#include<cstring>
using namespace std;

const int N = 110;
char st[N], ed[N];

void turn(int i){
    if(st[i] == '*') st[i] = 'o';
    else st[i] = '*';
}

int main(){
    int res = 0;
    cin >> st >> ed;
    int len = strlen(st);
    for(int i = 0; i < len - 1; i++)
        if(st[i] != ed[i]){
            res++;
            turn(i), turn(i + 1);
        }
    cout << res << endl;
    return 0;
}