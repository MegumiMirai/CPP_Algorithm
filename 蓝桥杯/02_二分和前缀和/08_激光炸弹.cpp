// 地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。

// 注意：不同目标可能在同一位置。

// 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。

// 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。

// 求一颗炸弹最多能炸掉地图上总价值为多少的目标。

// 输入格式
// 第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。

// 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。

// 输出格式
// 输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

// 数据范围
// 0≤R≤109
// 0<N≤10000,
// 0≤Xi,Yi≤5000
// 0≤Wi≤1000
// 输入样例：
// 2 1
// 0 0 1
// 1 1 1
// 输出样例：
// 1

// 思路：枚举每个区间，矩阵长度最大是5000，时间复杂度是O(nm)，最坏情况是2.5 * 10^7
#include<iostream>
using namespace std;

const int N = 5010;
int s[N][N]; // 用s数组来保存炸弹的价值，并且来计算矩阵的前缀和
int n, m; // n是矩阵的一维长度，m是矩阵的二维长度

int main(){
    int cnt, R; // cnt用来保存炸弹的个数，R表示轰炸的宽度，最多可以轰炸R*R范围的炸弹
    cin >> cnt >> R;
    R = min(R, 5001); // 轰炸范围过大和刚好效果是一样的，所以取最小值，同时也是为了后面的计算不越界
    n = m = R;
    while(cnt--){
        int x, y, z;
        cin >> x >> y >> z;
        x++, y++; // 题目给的下标都是从0开始的，但是使用前缀和，所以统一让所有的下标都是以1为开头
        n = max(n, x), m = max(m, y); // 让n变成炸弹的最大下标，是为了保证至少可以轰炸一次
        s[x][y] += z; // 因为炸弹可能在同一个地方放多个，所以累加价值
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j]; // 计算前缀和
    int res = 0;
    for(int i = R; i <= n; i++)
        for(int j = R; j <= m; j++){ // 下标都从R开始计算，防止有越界
            res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]); // 公式
        }
    cout << res << endl;
    
    return 0;
}