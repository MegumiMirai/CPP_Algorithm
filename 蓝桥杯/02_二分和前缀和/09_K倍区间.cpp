// 给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。

// 你能求出数列中总共有多少个 K 倍区间吗？

// 输入格式
// 第一行包含两个整数 N 和 K。

// 以下 N 行每行包含一个整数 Ai。

// 输出格式
// 输出一个整数，代表 K 倍区间的数目。

// 数据范围
// 1≤N,K≤100000,
// 1≤Ai≤100000
// 输入样例：
// 5 2
// 1
// 2
// 3
// 4
// 5
// 输出样例：
// 6

// 思路：通过固定右端点，从小到大枚举左端点，查看s[r]-s[l-1]模k是否为0，如果为0就让k倍区间数加1
// 但是时间复杂度是O(n^2)，所以需要进一步优化
// 当右端点R固定时，在1~R之间找到有多少个l满足(s[r] - s[l - 1]) % k == 0，变换一下就是在0~R-1之间找到有多少个l满足(s[r] - s[l]) % k == 0
// 也就是查找有多少个s[l]与s[r]的余数相同，比如说s[l]=15, s[r]=23, k=8, s[l]%k=7, s[r]%k=7, (s[r]-s[l])%k=0，那么[l,r]就是一个k倍区间
#include<iostream>
using namespace std;

typedef long long LL;
const int N = 1e5 + 10;
LL s[N], cnt[N]; // 如果每个数都是1e5，那么平方就是10^10，会爆int，所以使用long long
int n, k;

int main(){
    cin >> n >> k;
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        s[i] += s [i - 1]; // 获取前缀和数组
    }
    LL res = 0; // 记录有多少个k倍区间
    cnt[0] = 1; // 下面是从1开始枚举右端点的，实质上0%k等于0，把它自己算进去，其实下面从0开始枚举也能达到一样的效果
    for(int i = 1; i <= n; i++){ // 枚举右端点
        res += cnt[s[i] % k]; // 将所有s[l]%k等于s[i]%k的都加到res上，表示有这么多个k倍区间
        cnt[s[i] % k]++; // 再把自身算进去
    }
    cout << res << endl;
    return 0;
}