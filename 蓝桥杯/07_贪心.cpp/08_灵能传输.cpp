// 在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。

// 经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。

// 你控制着 n 名高阶圣堂武士，方便起见标为 1,2,⋅⋅⋅,n。

// 每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。

// 现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i∈[2,n−1]，若 ai≥0 则其两旁的高阶圣堂武士，也就是 i−1、i+1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai<0 则其两旁的高阶圣堂武士，也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。

// 形式化来讲就是 ai−1+=ai,ai+1+=ai,ai−=2ai。

// 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxni=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。

// 输入格式
// 本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。

// 接下来依次输入每一组询问。

// 每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。

// 接下来一行包含 n 个数 a1,a2,⋅⋅⋅,an。

// 输出格式
// 输出 T 行。

// 每行一个整数依次表示每组询问的答案。

// 数据范围
// 1≤T≤3,3≤n≤300000,|ai|≤109,
// 每个评测用例的限制如下：

// QQ截图20191205220735.png

// 输入样例1：
// 3
// 3
// 5 -2 3
// 4
// 0 0 0 0
// 3
// 1 2 3
// 输出样例1：
// 3
// 0
// 3
// 输入样例2：
// 3
// 4
// -1 -2 -3 7
// 4
// 2 3 4 -8
// 5
// -1 -1 6 -1 -1
// 输出样例2：
// 5
// 7
// 4
// 样例解释
// 样例一
// 对于第一组询问：
// 对 2 号高阶圣堂武士进行传输操作后 a1=3，a2=2，a3=1。答案为 3。
// 对于第二组询问：
// 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。

/*
用a保存灵能，s保存灵能的前缀和
  s1 = a1
  s2 = a1 + a2
  s3 = a1 + a2 + a3
  s4 = a1 + a2 + a3 + a4
如果a3把灵能传给a2和a4，就可以得到
  a2 = a2 + a3
  a3 = a3 - 2a3
  a4 = a4 + a3
此时
  s1 = a1
  s2 = a1 + a2 + a3 = s3
  s3 = a1 + a2 + a3 + a3 - 2a3 = a1 + a2 = s2
  a4 = a1 + a2 + a3 + a4 - 2a3 + a4 - a3 = s4
可以看出来对原序列的操作可以看做是交换两个前缀和，交换只能在2 ~ n-1中间进行，
那么原题的意思可以转化为在交换了之后的前缀和数组中在求差分数组，令差分数组中绝对值最大的数最小
s0和sn是不能移动的，也就是说存在最小值比s0小，存在最大值比sn更大
求差分时需要先从s0到最小值，然后再从最小值到最大值，最终从最大值到sn，有两段是要走两次的
因此再从s0到最小值时是每隔一个数跳一次，这样可以保证最终的差分是最小的，我也不知道为什么，反正可以证出来
思路就是以上
*/
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long LL;
const int N = 3e5 + 10;
int n;
LL a[N], s[N]; // s保存灵能，s保存前缀和
bool st[N]; // 查重数组

int main(){
    int T;
    cin >> T;
    while(T--){
        cin >> n;
        s[0] = 0; // s[0]都固定设置为0
        for(int i = 1; i <= n; i++){
            cin >> a[i];
            s[i] = s[i - 1] + a[i];
        }
        
        LL s0 = s[0], sn = s[n]; // s0和sn是固定不动的
        if(s0 > sn) swap(s0, sn); // 如果s0大于sn，交换后按照上面的方法做
        sort(s, s + n + 1); // 排序
        
        for(int i = 0; i <= n; i++) // 获取s0位置的下标
            if(s[i] == s0){
                s0 = i;
                break;
            }
            
        for(int i = n; i >= 0; i--) // 获取sn位置的下标
            if(s[i] == sn){
                sn = i;
                break;
            }
            
        memset(st, 0, sizeof st); // 重置查重数组 
        int l = 0, r = n; // 定义左右两个下标，用来给s数组赋值
        for(int i = s0; i >= 0; i -= 2){ // 先从s0到最小值，每次隔一个数，所以 i -= 2
            a[l++] = s[i];
            st[i] = true;
        }
        for(int i = sn; i <= n; i += 2){ // 从sn到最大值，每次个一个数，所以 i += 2
            a[r--] = s[i];
            st[i] = true;
        }
        for(int i = 0; i <= n; i++) // 最后从头遍历一遍，给s数组赋值
            if(!st[i])
                a[l++] = s[i];
                
        LL res = 0;
        for(int i = 1; i <= n; i++)
            res = max(res, abs(a[i] - a[i - 1])); // 然后在差分中求绝对值的最大值
            
        cout << res << endl;
    }
    
    return 0;
}