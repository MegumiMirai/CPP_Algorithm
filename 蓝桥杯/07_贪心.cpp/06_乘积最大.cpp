// 给定 N 个整数 A1,A2,…AN。

// 请你从中选出 K 个数，使其乘积最大。

// 请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009 的余数。

// 注意，如果 X<0， 我们定义 X 除以 1000000009 的余数是负(−X)除以 1000000009 的余数，即：0−((0−x)%1000000009)
// 输入格式
// 第一行包含两个整数 N 和 K。

// 以下 N 行每行一个整数 Ai。

// 输出格式
// 输出一个整数，表示答案。

// 数据范围
// 1≤K≤N≤105,
// −105≤Ai≤105
// 输入样例1：
// 5 3
// -100000
// -10000
// 2
// 100000
// 10000
// 输出样例1：
// 999100009
// 输入样例2：
// 5 3
// -100000
// -100000
// -2
// -100000
// -100000
// 输出样例2：
// -999999829

/*
思路：
    对 a1 - an 进行排序
    1. 如果 k == n，那么所有数都要乘起来
    2. 如果 k < n
        (1) 如果k是偶数，结果必然为非负 因为 如果负数有偶数个，那么必然大于等于0，如果负数有奇数个，那么选择偶数个负数，偶数个正数，保证了结果大于等于0
        (2) 如果k是奇数，如果所有数都是负数，那么结果 < 0
                        如果存在一个是非负数，那么结果必然 >= 0，此时选择这个非负数，偶数个负数，保证了结果 >= 0
                        如果都是非负，那么结果 >= 0
    虽然看上去要分类讨论那么多，其实可以合成为1个，如果是奇数，那么先选择最大的那个，然后后面的就按偶数个那么计算，每次从前面或者后面选择两个，选择会使
    结果最大的那个乘积乘上去，如果结果必然为负数，那么就选择绝对值小的，如果必然为正数，就选择绝对值大的
*/
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long LL;

const int N = 1e5 + 10, mod = 1000000009;

int n, k;
int a[N];

int main(){
    cin >> n >> k;
    for(int i = 0; i < n; i++) cin >> a[i];
    sort(a, a + n); 
    
    int res = 1; // 计算最终结果
    int l = 0, r = n - 1;
    int sign = 1; // 记录最终结果是正数还是负数
    if(k % 2){ // 如果k是奇数
        res = a[r--]; // 先选择最大的那个数
        k--; 
        if(res < 0) sign = -1; // 如果最大的那个数是负数，那么表明结果必然为负数，此时就要选择绝对值小的那个
    }
    while(k){ // k为偶数，每次 -= 2
        LL x = (LL)a[l] * a[l + 1], y = (LL)a[r - 1] * a[r]; // x是最小的两个数的乘积，y是最大的两个数的乘积
        if(x * sign > y * sign){ // 这里 乘以sign意思是如果sign是1，表明最终结果是正数，选择绝对值大的那个，如果sign是-1，表明最终结果是负数选择绝对值小的
            res = x % mod * res % mod; // x可能爆int了，所以先mod，在乘，在mod
            l += 2; 
        }else{
            res = y % mod * res % mod; // 右边也同样是这个道理
            r -= 2;
        }
        k -= 2;
    }
    
    cout << res << endl; 
    
    return 0;
}