// 众所周知，小葱同学擅长计算，尤其擅长计算一个数是否是另外一个数的倍数。

// 但小葱只擅长两个数的情况，当有很多个数之后就会比较苦恼。

// 现在小葱给了你 n 个数，希望你从这 n 个数中找到三个数，使得这三个数的和是 K 的倍数，且这个和最大。

// 数据保证一定有解。

// 输入格式
// 第一行包括 2 个正整数 n, K。

// 第二行 n 个正整数，代表给定的 n 个数。

// 输出格式
// 输出一行一个整数代表所求的和。

// 数据范围
// 1≤n≤105,
// 1≤K≤103,
// 给定的 n 个数均不超过 108
// 输入样例：
// 4 3
// 1 2 3 4
// 输出样例：
// 9

/*
状态表示f[i][j][k] 
  集合：所有从前i个数中选，且已经选了j个数，且总和模K的余数是k的选法的集合
  属性：Max
状态计算：分成两个，选择第i个数和不选择
  1.不选择第i个数 f[i-1][j][k]
  2.选择第i个数，就是说从前1~i-1中选择j-1个数，假设它们的总和是x，使得(x + ai) % K = k，所以x = (k - ai) % K，也就是f[i - 1][j - 1][(k - ai) % K] + ai
  在二者中选择较大值
时间复杂度是 N * 3 * K = 3e8，可能会卡住，所以需要优化
比如说 2 3 5这三个数选择mod5的，那么选择2 3 5，如果有一个7就不会选2而是7，也就是说如果两个数mod K 是相同的，那么会优先选择较大者
所有再从控制台中输入的时候可以将他们进行分类
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;
const int N = 1010; // 以K为大小开数组

int n, m;
vector<int> a[N]; // 保存mod K的数
int f[4][N]; 

int main(){
    cin >> n >> m;
    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        a[x % m].push_back(x);
    }
    
    memset(f, -0x3f, sizeof f); // 选择0个物品但是模K不是0是没有意义的，所以先把他们都重置成无穷小
    f[0][0] = 0; // 选择0个数，模K是0的数的和为0
    
    for(int i = 0; i < m; i++){ // 枚举mod K的vector
        sort(a[i].begin(), a[i].end()); // 先从小到大排序
        reverse(a[i].begin(), a[i].end()); // 然后倒序就是从大到小
        
        for(int u = 0; u < 3 && a[i].size(); u++){ // 选择前三个数，这是因为有可能最大的三个数mod K余数是相同的，即都是K的倍数获得余数相加是K的倍数
            int x = a[i][u];
            for(int j = 3; j >= 1; j--) // 枚举选了几个数，因为下面是f[j-1]用到了上一层的数据，所以需要从大往小
                for(int k = 0; k < m; k++)  // 枚举mod K
                    f[j][k] = max(f[j][k], f[j - 1][(k - x % m + m) % m] + x); // 去较大值
        }
    }
    
    cout << f[3][0] << endl; // 最终输出有3个数，mod K为0的总和
    
    return 0;
}