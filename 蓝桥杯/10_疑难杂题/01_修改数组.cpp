// 给定一个长度为 N 的数组 A=[A1,A2,⋅⋅⋅AN]，数组中有可能有重复出现的整数。

// 现在小明要按以下方法将其修改为没有重复整数的数组。

// 小明会依次修改 A2,A3,⋅⋅⋅,AN。

// 当修改 Ai 时，小明会检查 Ai 是否在 A1∼Ai−1 中出现过。

// 如果出现过，则小明会给 Ai 加上 1；如果新的 Ai 仍在之前出现过，小明会持续给 Ai 加 1，直到 Ai 没有在 A1∼Ai−1 中出现过。

// 当 AN 也经过上述修改之后，显然 A 数组中就没有重复的整数了。

// 现在给定初始的 A 数组，请你计算出最终的 A 数组。

// 输入格式
// 第一行包含一个整数 N。

// 第二行包含 N 个整数 A1,A2,⋅⋅⋅,AN。

// 输出格式
// 输出 N 个整数，依次是最终的 A1,A2,⋅⋅⋅,AN。

// 数据范围
// 1≤N≤105,
// 1≤Ai≤106
// 输入样例：
// 5
// 2 1 1 3 4
// 输出样例：
// 2 1 3 4 5

// 使用并查集，先把从N个数的根节点设置成它自己，然后从控制台一个一个读取数据，先查询它的根节点，输出，随后把它的根节点向后移一个
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 1e6 + 10;
int p[N]; // 保存根节点

int find(int x){
    if(x != p[x]) p[x] = find(p[x]);s
    return p[x];
}

int main()
{
    int n;
    cin >> n;
    
    for(int i = 1; i < N; i++) p[i] = i; // 先把N个数父节点设置成他自己
    for(int i = 1; i <= n; i++){
        int x; 
        cin >> x;
        x = find(x); // 每次先查询它的根节点
        cout << x << " "; // 输出
        p[x] = x + 1; // 然后把它设置成根节点的下一个
    }
    
    return 0;
}