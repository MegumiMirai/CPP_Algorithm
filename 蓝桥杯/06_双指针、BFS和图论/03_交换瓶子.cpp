// 有 N 个瓶子，编号 1∼N，放在架子上。

// 比如有 5 个瓶子：

// 2 1 3 5 4
// 要求每次拿起 2 个瓶子，交换它们的位置。

// 经过若干次后，使得瓶子的序号为：

// 1 2 3 4 5
// 对于这么简单的情况，显然，至少需要交换 2 次就可以复位。

// 如果瓶子更多呢？你可以通过编程来解决。

// 输入格式
// 第一行包含一个整数 N，表示瓶子数量。

// 第二行包含 N 个整数，表示瓶子目前的排列状况。

// 输出格式
// 输出一个正整数，表示至少交换多少次，才能完成排序。

// 数据范围
// 1≤N≤10000,

// 输入样例1：
// 5
// 3 1 2 5 4
// 输出样例1：
// 3
// 输入样例2：
// 5
// 5 4 3 2 1
// 输出样例2：
// 2

// 我写的代码
/*
思路：在该点到该点的值连一根线，最终是要有n个环，每个环从自己连向自己，共有k个环，最少交换的次数是 n - k
如果交换一个环内的两个点，一个环会变成两个环
如果交换两个环内的点，两个环会变成一个
如果只交换环内的两个点，最终可以做到最少交换
*/
#include<iostream>
using namespace std;

const int N = 10010;
int a[N]; // 记录从控制台的输入
bool st[N]; // 记录该点是否已经在某个环中的

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    int res = 0; // 保存共有几个环
    for(int i = 1; i <= n; i++){
        if(!st[i]){ // 如果i位置还没有归属于一个环，则把它当做环的起点，然后往后走
            int x = i; 
            res++; // 表示环的数目增加一个
            while(!st[x]){ // 直到回到i位置，向后遍历
                st[x] = true; // 每遍历到一个点，把它设置为在一个环中了
                x = a[x]; // 然后前往下一个点
            }
        }
    }
    cout << n - res << endl;
    return 0;
}

// 大佬的代码
#include<iostream>
using namespace std;

const int N = 10010;
int b[N];
bool st[N];

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> b[i];
    
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        if(!st[i]){
            cnt++;
            for(int j = i; !st[j]; j = b[j])
                st[j] = true;
        }
    }
    cout << n - cnt << endl;
    return 0;
}