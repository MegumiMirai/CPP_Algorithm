// 输入一个包含 n 个方程 n 个未知数的异或线性方程组。

// 方程组中的系数和常数为 0 或 1，每个未知数的取值也为 0 或 1。

// 求解这个方程组。

// 异或线性方程组示例如下：

// M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]
// M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]
// …
// M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n]
// 其中 ^ 表示异或(XOR)，M[i][j] 表示第 i 个式子中 x[j] 的系数，B[i] 是第 i 个方程右端的常数，取值均为 0 或 1。

// 输入格式
// 第一行包含整数 n。

// 接下来 n 行，每行包含 n+1 个整数 0 或 1，表示一个方程的 n 个系数以及等号右侧的常数。

// 输出格式
// 如果给定线性方程组存在唯一解，则输出共 n 行，其中第 i 行输出第 i 个未知数的解。

// 如果给定线性方程组存在多组解，则输出 Multiple sets of solutions。

// 如果给定线性方程组无解，则输出 No solution。

// 数据范围
// 1≤n≤100
// 输入样例：
// 3
// 1 1 0 1
// 0 1 1 0
// 1 0 0 1
// 输出样例：
// 1
// 0
// 0

/*
这道题的步骤与求普通的线性方程组的步骤是一样的，都是先把他化成上三角，判断这个三角是否是满的，如果没有满就判断有没有矛盾，有矛盾就说明无解，无矛盾就说明有无穷多组解
如果是有唯一解，就从下往上异或，直到每一行只有一列是等于1
*/
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 110;
int a[N][N];
int n;

int gauss(){
    int r, c;
    // 枚举每一列
    for(r = 0, c = 0; c < n; c++){
        int t = r;
        for(int i = r; i < n; i++) // 这个循环的目的是查找第c列为1的一行
            if(a[i][c]){
                t = i;
                break;
            }
        // 如果没有找到第c列为1的一行，就进行下一轮循环
        if(!a[t][c]) continue;
        // 然后把第c列为1的这一行换到第r行
        for(int i = c; i < n + 1; i++) swap(a[r][i], a[t][i]);
        for(int i = r + 1; i < n; i++)  // 然后把第r行第c列下面为1的那一行，把第c列以后的每一个数据都与第r行后面的数据异或，使得只有第r行的第c列为1
            if(a[i][c])
                for(int j = c; j < n + 1; j++)
                    a[i][j] ^= a[r][j];
        r++; // r++表示可以进行下一轮的操作
    }
    if(r < n){ // 如果r小于n，就表示可能无解或有无穷多组解
        for(int i = r; i < n; i++) // 如果从第r行开始后面的一行中最后一个元素不为0，就造成了 0 == 1 的局面，出现矛盾，表示无解
            if(a[i][n]) return -1;
        return 1; // 如果没有出现矛盾，就说明有无穷多组解
    }
    // 从最后一行开始，把这一行第一个非零元素后面为1的那一个数据与第j行的第n个数据异或，最终就可以得到最简行阶梯矩阵，得到答案
    for(int i = n - 1; i >= 0; i--)
        for(int j = i + 1; j < n; j++)
            a[i][n] ^= a[i][j] & a[j][n]; // 只有当a[i][j]为1的时候，才能使得a[i][n]与a[j][n]异或是有效的，因为如果a[i][j]等于0，不管a[j][n]是什么，
                                          // a[i][j] & a[j][n] 的结果都是0，使得a[i][n]异或上0结果仍然是它自己，不会改变，但是如果a[i][j]是1，
                                          // a[i][j] & a[j][n] 的结果就是a[j][n]，从结果上说就是a[i][n] ^= a[j][n]，这也是所追求的，省去了判断1的步骤
    return 0; // 返回0表示有唯一解
            
}

int main(){
    cin >> n;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n + 1; j++) cin >> a[i][j]; // 从控制台获取数据
    int t = gauss(); // 通过返回值t判断是否有解以及解的个数
    // 规定如果t等于0，说明有唯一解，把a数组每一行最后一个数据输出，如果t等于1，就说明有去穷多组解，如果t等于-1，就表示无解
    if(t == 0)
        for(int i = 0; i < n; i++) 
            cout << a[i][n] << endl;
    else if(t == 1) puts("Multiple sets of solutions");
    else puts("No solution");
    
    return 0;
}