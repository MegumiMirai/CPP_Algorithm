// 给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。

// 请你求出 1∼n 中能被 p1,p2,…,pm 中的至少一个数整除的整数有多少个。

// 输入格式
// 第一行包含整数 n 和 m。

// 第二行包含 m 个质数。

// 输出格式
// 输出一个整数，表示满足条件的整数的个数。

// 数据范围
// 1≤m≤16,
// 1≤n,pi≤109
// 输入样例：
// 10 2
// 2 3
// 输出样例：
// 7


/*
容斥原理一个典型案例就是韦恩图，比如说有圈1、2、3，1和2有交集，1和3有交集，2和3有交集，1、2、3有交集，问集合1、2、3一共有多少个数
就可以表示成 P1 + P2 + P3 - P1 ∩ P2 - P1 ∩ P3 - P2 ∩ P3 + P1 ∩ P2 ∩ P3
用组合数表示就是 C(3, 1) - C(3, 2) + C(3, 3)

这道题用暴力做法时间复杂度是 16 * 1e9，肯定会超时，1秒计算器大概可以执行 1e7 - 1e8 的时间复杂度
C(n, 0) + C(n, 1) + ... + C(n, n) = 2^n，当n等于16的时候，结果是65536，可以执行成功
*/ 
#include<iostream>
using namespace std;

typedef long long LL;
const int N = 20;
int primes[N]; // 保存m个质数

int main(){
    int n, m;
    cin >> n >> m;
    for(int i = 0; i < m; i++) cin >> primes[i];
    int res = 0; // 用来保存最后的结果
    for(int i = 1; i < 1 << m; i++){ // 1<<m 表示一共有那么多种选择，比如说m等于3，把它变成二进制，就是 1000 等于8，表示一共有8种选法
        int t = 1, cnt = 0; // t是这些数的乘积，cnt表示有多少个数乘起来
        for(int j = 0; j < m; j++){ // 质数一共有m个，所以i最多可以右移m-1位
            if(i >> j & 1){ // 如果这一位是1
                cnt++; // 就让cnt++
                if((LL)t * primes[j] > n){ // 如果乘积大于n，就表示不可能会有这个数的倍数，所以把t设置成-1，表示没有交集
                    t = -1;
                    break;
                }
                t *= primes[j]; // 如果没有超出范围，就乘上
            }
        }
        if(t == -1) continue; // 如果t==-1，表示没有倍数，继续下一轮循环
        if(cnt % 2) res += n / t; // 如果选择的个数不是2的倍数，就让res加上n除以t，表示有这么多个它的倍数
        else res -= n / t; // 否则，就是减去
    }
    cout << res << endl;
    return 0;
}