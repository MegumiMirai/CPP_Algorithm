// 现在，有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i 级台阶上有 ai 个石子(i≥1)。

// 两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

// 已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

// 问如果两人都采用最优策略，先手是否必胜。

// 输入格式
// 第一行包含整数 n。

// 第二行包含 n 个整数，其中第 i 个整数表示第 i 级台阶上的石子数 ai。

// 输出格式
// 如果先手方必胜，则输出 Yes。

// 否则，输出 No。

// 数据范围
// 1≤n≤105,
// 1≤ai≤109
// 输入样例：
// 3
// 2 1 3
// 输出样例：
// Yes

/*
首先说结论：如果奇数台阶上的石子的个数异或起来不等于0，就是先手必胜，反之就是先手必败
用符号来表示就是 a1 ^ a2 ^ ... ^ an != 0 -> 先手必胜，a1 ^ a2 ^ ... ^ an == 0 -> 先手必败
这是因为 0 ^ 0 ^ 0 ^ ... ^ 0 = 0，所以当对方回合的时候一直保持奇数台阶石子个数异或等于0，最终必定会保证对方回合的时候没有了石子
每一步敌我双方都采用最优解，所以当对方将偶数阶梯上的n个石子放到下一阶梯之后，我方把放在下一阶梯上的n个石子再放到下一阶梯，就能保证奇数阶梯异或为0
当对方把奇数阶梯上的n个石子放到下一阶梯后，根据之前的Nim游戏，我方必定有一种方法，从某一阶梯上拿走n个石子保证奇数阶梯上的石子异或仍然是0
*/
#include<iostream>
using namespace std;

int main(){
    int n, res = 0;
    cin >> n;
    for(int i = 1; i <= n; i++){
        int x;
        cin >> x;
        if(i % 2) res ^= x;
    }
    if(res) puts("Yes");
    else puts("No");
    return 0;
}