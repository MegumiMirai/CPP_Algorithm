// 给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。

// 输出的答案对 109+7 取模。

// 输入格式
// 共一行，包含整数 n。

// 输出格式
// 共一行，包含一个整数，表示答案。

// 数据范围
// 1≤n≤105
// 输入样例：
// 3
// 输出样例：
// 5

/*
思路：把它想成一个路径问题，比如说n等于6，那么题目可以变成下面这个样子
6                 *
5
4
3
2
1
0  1  2  3  4  5  6
要求从0点到*的路径问题，把题目的0想成向右走一格，1表示向上走一格，那么题目要求的前缀序列中 0 的个数都不少于 1 的个数的序列就可以想成将0与*连成一条线
它的斜率是1，所以要保证从0到*的过程中不能走到这条斜线的上面，如果走到了上面就不符合题目的要求了，也就是说如果路径经过了（0，1）到（5，6）这条线上的点
就说明不合法了，此时的(6,6)点关于这条线的对称点是(5, 7)
所以当n等于6的时候，答案就是C(12, 6)-C(12, 5)，C(12, 6)可以想成这12步中向右走了6步，此时它一定会走到(6, 6)点，但是向右走了6步，他还是会有非法的路径
如果是经过了那条线到的(6,6)点，他就是不合法的，要消去，此时把经过了那条线后面的路径关于这条线做轴对称，它的终点是(5,7)，所以就是减C(12,5)
所以就是C(2n, n) - C(2n, n - 1) = ((2n)! / (n! * n!)) - ((2n)! / (n+1)! * (n-1)!) = ((2n)! * (n+1) - (2n)! * n) / ((n+1)! * n!)
= (2n)! / (n! * n!) / n+1 = C(2n, n) / (n+1)
*/
#include<iostream>
using namespace std;

typedef long long LL;

const int mod = 1e9 + 7;

int qmi(int a, int k, int p){
    int res = 1;
    while(k){
        if(k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main(){
    int n;
    cin >> n;
    int a = 2 * n, b = n;
    int res = 1;
    
    for(int i = a; i > a - b; i--) res = (LL)res * i % mod; // 求C(2n, n)的分母的阶乘的乘积
    for(int i = n; i > 0; i--) res = (LL)res * qmi(i, mod - 2, mod) % mod; // 求C(2n, n)的分子的乘积，使用逆元
    
    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod; // 最后要除以 n+1，也就是乘以它的逆元
    
    cout << res << endl;
    
    return 0;
}