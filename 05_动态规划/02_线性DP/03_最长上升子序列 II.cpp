// 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

// 输入格式
// 第一行包含整数 N。

// 第二行包含 N 个整数，表示完整序列。

// 输出格式
// 输出一个整数，表示最大长度。

// 数据范围
// 1≤N≤100000，
// −109≤数列中的数≤109
// 输入样例：
// 7
// 3 1 2 1 8 5 6
// 输出样例：
// 4

/*
数据都强化了，如果还是用暴力做法 O(n^2)就是10^6^2 = 10^12，必然会TLE
我们可以这么想，我们为一个位置查找以它为结尾的最长上升子序列，那么就要查找前面的要满足两个条件，一个是它保存的值要比当前的小，另一个是它的最长子序列值得是
最大的，那么我们可以用一个数组，保存当最长子序列是i的时候它保存的值得最小值，比如说当遍历到的数据是5，前面子序列长度为3时，有数据4和5，那么我们只需要保存
4即可，因为它的适用范围更广，此时就可以把5当成子序列长度为4的那个值，而且保存的这个值是递增的
查找的时候使用二分，所以时间复杂度就是O(nlogn)
*/
#include<iostream>
using namespace std;

const int N = 1e6 + 10;
int a[N], q[N]; // a数组用来保存从控制台读入的数据，q数组用来保存当子序列长度为i时它保存的数据的最小值

int main(){
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) cin >> a[i];
    
    int len = 0;
    q[0] = -2e9; // 先要把0这个位置定义成无穷小
    for(int i = 0; i < n; i++){
        int l = 0, r = len;
        while(l < r){
            int mid = l + r + 1 >> 1; // 因为要分成[l, mid-1]、[mid, r]，所以得是 l + r + 1，避免死循环
            if(q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);  // 如果不存在比他大的数，那么它就要放在最右边
        q[r + 1] = a[i];
    }
        
    cout << len << endl;
    
    return 0;
}