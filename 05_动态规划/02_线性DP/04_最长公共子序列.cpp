// 给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

// 输入格式
// 第一行包含两个整数 N 和 M。

// 第二行包含一个长度为 N 的字符串，表示字符串 A。

// 第三行包含一个长度为 M 的字符串，表示字符串 B。

// 字符串均由小写字母构成。

// 输出格式
// 输出一个整数，表示最大长度。

// 数据范围
// 1≤N,M≤1000
// 输入样例：
// 4 5
// acbd
// abedc
// 输出样例：
// 3

/*
状态表示f[i,j]
    集合：所有在第一个序列的前i个子母中出现，并且在第二个序列的前j个子母中出现的子序列
    属性：Max
状态计算：可以分成四个部分
        1. 不包含第i个且不包含第j个，表示为f[i-1][j-1]
        2. 不包含第i个，包含第j个，f[i-1][j]
        3. 包含第i个，不包含第j个，f[i][j-1]
        4. 既包含第i个，也包含第j个，f[i-1][j-1] + 1
但是要注意，这里的第二种和第三种情况，按照集合的意思，f[i-1][j]应该表示成一定第一个序列以第i-1个结尾，第二个序列一定以第j个结尾，但是我们想要的是
在第一个序列前i-1个字母中出现并且在第二个序列前j个子母中出现的最长子序列长度，但是它是可以表示成那样的，为什么呢？那是因为前者是包含在后者中的，即
第一个序列以第i-1个结尾，第二个序列一定以第j个结尾 是包含在 在第一个序列前i-1个字母中出现并且在第二个序列前j个子母中出现的最长子序列中的
也可以说前者的最长子序列是小等于后者的最长子序列的，我们可以选择更大的，但是绝对不可以选择更小的，所以就这么表示是可以的

其实第一种情况可以不予考虑，因为第一种情况是包含在第二、三种情况中的，但是第四种情况只有当第一个序列的第i个字母等于第二个序列的第j个字母才成立，所以
我们可以现在第二三种情况中选择较大值，如果第四种情况成立了，在拿较大者跟第四种情况比较，再选取更大值，然后存放在f中
结果就是f[n][m]，表示第一个序列前n个字母中出现并且第二个序列前m个子母中出现的最长子序列长度
*/
#include<iostream>
using namespace std;

const int N = 1010;
char a[N], b[N];
int f[N][N];

int main(){
    int n, m;
    cin >> n >> m;
    cin >> a + 1 >> b + 1; // a和b数组从下标为1开始读入
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        }
    cout << f[n][m];
    return 0;
}