// 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。

// 例如，a=1024，b=1032，则 a 和 b 之间共有 9 个数如下：

// 1024 1025 1026 1027 1028 1029 1030 1031 1032

// 其中 0 出现 10 次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…

// 输入格式
// 输入包含多组测试数据。

// 每组测试数据占一行，包含两个整数 a 和 b。

// 当读入一行为 0 0 时，表示输入终止，且该行不作处理。

// 输出格式
// 每组数据输出一个结果，每个结果占一行。

// 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。

// 数据范围
// 0<a,b<100000000
// 输入样例：
// 1 10
// 44 497
// 346 542
// 1199 1748
// 1496 1403
// 1004 503
// 1714 190
// 1317 854
// 1976 494
// 1001 1960
// 0 0
// 输出样例：
// 1 2 1 1 1 1 1 1 1 1
// 85 185 185 185 190 96 96 96 95 93
// 40 40 40 93 136 82 40 40 40 40
// 115 666 215 215 214 205 205 154 105 106
// 16 113 19 20 114 20 20 19 19 16
// 107 105 100 101 101 197 200 200 200 200
// 413 1133 503 503 503 502 502 417 402 412
// 196 512 186 104 87 93 97 97 142 196
// 398 1375 398 398 405 499 499 495 488 471
// 294 1256 296 296 296 296 287 286 286 247

/*
如果使用暴力做法，每个数是在1-1e8，枚举每一位就是 8，一共要计算0-9，一共十个数，区间的两个数最大是1e8，所以时间复杂度是O(8 * 10 * 1e8)，这还只是
一个测试案例，肯定会TLE
做法：
比如说给你一个数区间[a, b]，要求这里面某个数出现的次数，假设count(n, x)这个函数是计算1-n这些数中x出现的次数，那么区间[a, b]中x出现的次数
就是 count(b, x) - count(a - 1, x)
那么假设右区间abcdefg，我们要求第四位是1出现的次数，即xxx1yyy，1 <= xxx1yyy <= abcdefg 分情况讨论：
    1. xxx = 000 ~ abc - 1，那么y可以取 000 ~ 999，所以有 abc * 1000 个
    2. 如果 xxx = abc
        (1). 如果给定右区间的 d < 1，那么abc1yyy > abcdefg，此时超出范围，所以没有
        (2). 如果 d = 1，此时 yyy = 000 ~ efg，共出现 efg + 1 次
        (3). 如果 d > 1，那么 yyy 可以取 000 ~ 999，共出现 1000 次
    然后把这些第一种和第二种情况中符合条件的两个加起来，就是x在1~n中出现的次数
但是有边界情况
    1. 如果要求的x的次数，当x出现在最高位时，它是没有第一种情况的，所以只需要计算第二种情况
    2. 如果x = 0，那么第一种情况要取 001 ~ abc - 1，因为要保证不能出现前导0，比如说 1230456，那么0000456，这个时候不能把第四位当成0算进去
*/
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int get(vector<int> num, int l, int r){ // 这个函数是用来在vector中求abc和efg
    int res = 0;
    for(int i = l; i >= r; i--)
        res = res * 10 + num[i];
    return res;
}

int power10(int x){ // 这个函数是求10的x次方
    int res = 1;
    while(x--) res *= 10;
    return res;
}

int count(int n, int x){
    if(!n) return 0; // 如果题目求的是 1-abc，那么左区间 1 - 1 = 0，可以直接忽略，因为本身这个函数就是为了求1-n中x出现的次数
    // 把n这个数从低位到高位一次push进vector中
    vector<int> num;
    while(n){
        num.push_back(n % 10);
        n /= 10;
    }
    
    n = num.size(); // 获得n这个数的位数
    
    int res = 0; // res就是1-n中x出现的次数
    for(int i = n - 1 - !x; i >= 0; i--){ // 如果x是0，那么他不可能出现在最高位，所以从次高位开始计算
        if(i < n - 1){ // 如果x是在最高位，不考虑第一种情况
            res += get(num, n - 1, i + 1) * power10(i); // xxx = 000 ~ abc - 1，那么y可以取 000 ~ 999，所以有 abc * 1000 个
            if(!x) res -= power10(i); // 但是如果x是0，属于边界情况，不能是000，所以把它除去
        }
        if(num[i] == x) res += get(num, i - 1, 0) + 1; // 如果 d = x，此时 yyy = 000 ~ efg，共出现 efg + 1 次
        else if(num[i] > x) res += power10(i); // 如果 d > 1，那么 yyy 可以取 000 ~ 999，共出现 1000 次
    }
    
    return res;
}

int main(){
    int a, b;
    while(cin >> a >> b, a || b){
        if(a > b) swap(a, b); // 如果前者大于后者，交换
        for(int i = 0; i < 10; i++)
            cout << count(b, i) - count(a - 1, i) << " "; // 公式，类似前缀和
        cout << endl;
    }
    
    return 0;
}