// Ural 大学有 N 名职员，编号为 1∼N。

// 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

// 每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。

// 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

// 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

// 输入格式
// 第一行一个整数 N。

// 接下来 N 行，第 i 行表示 i 号职员的快乐指数 Hi。

// 接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。

// 输出格式
// 输出最大的快乐指数。

// 数据范围
// 1≤N≤6000,
// −128≤Hi≤127
// 输入样例：
// 7
// 1
// 1
// 1
// 1
// 1
// 1
// 1
// 1 3
// 2 3
// 6 4
// 7 4
// 4 5
// 3 5
// 输出样例：
// 5


/*
状态表示f[u,0], f[u,1],有两个
  集合：f[u,0]表示所有以u为根的子树中选择，并且不选u这个点的方案
        f[u,1]表示所有以u为根的子树中选择，并且选择u这个点的方案
  属性：Max

  如果不选u这个节点，那么u的所有子节点都可以选择选或者不选，那么取二者中较大者即可
  但如果要选择u这个节点，那么u的所有子节点都是不可以选的
  那么可以得到下面两个公式：
    f[u, 0] = max(f[s1, 0], f[s1, 1]) + max(f[s2, 0], f[s2, 1]) + ... + max(f[si, 0], f[si, 1])
      如果不选u这个节点，就把它所有子节点的子树中获取较大值，然后相加
    f[u, 1] = f[s1, 0] + f[s2, 0] + ... + f[si, 0]
      如果选择u这个节点，那么它的子节点都不能选择，所有只能把所有不把子节点算上的情况都相加

  因为除了根节点每个节点都要遍历一遍，所以时间复杂度是 O(n - 1) = O(n)
*/
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 6010;
int n;
int happy[N]; // 存储快乐指数
int h[N], e[N], ne[N], idx; // 树用邻接表存储
int f[N][2]; // 表示状态
bool has_father[N]; // 查看一个节点是否有父节点

void add(int a, int b){
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int u){
    f[u][1] = happy[u]; // 如果选择u这个节点，那么首先把它自己的快乐值加上
    for(int i = h[u]; i != -1; i = ne[i]){ // 遍历这个点的子节点
        int j = e[i];
        dfs(j); // 如果这个子节点还有子节点，继续往下遍历
        
        f[u][0] += max(f[j][0], f[j][1]); // 如公式所说，不选择父节点，那么就把所有子节点所在的子树快乐值的较大值累加上
        f[u][1] += f[j][0]; // 如果选择了父节点，那么只能在每个子节点的子树中选择没有父节点的快乐值
    }
}

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> happy[i]; // 从控制台读入1-n的快乐指数
    memset(h, -1, sizeof h); // 将每个点所在的邻接表的尾节点都设置成-1
    for(int i = 0; i < n - 1; i++){ // 保存进邻接表
        int a, b;
        cin >> a >> b;
        has_father[a] = true;
        add(b, a);
    }
    
    int root = 1;
    while(has_father[root]) root++; // 为了查找根节点1
    
    dfs(root);
    
    cout << max(f[root][0], f[root][1]) << endl; // 在选择根节点和不选择根节点输出较大值，即为快乐值的最大值
    
    return 0;
}