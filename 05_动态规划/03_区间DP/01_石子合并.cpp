// 设有 N 堆石子排成一排，其编号为 1，2，3，…，N。

// 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

// 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

// 例如有 4 堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1，2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；

// 如果第二步是先合并 2，3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。

// 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

// 输入格式
// 第一行一个数 N 表示石子的堆数 N。

// 第二行 N 个数，表示每堆石子的质量(均不超过 1000)。

// 输出格式
// 输出一个整数，表示最小代价。

// 数据范围
// 1≤N≤300
// 输入样例：
// 4
// 1 3 5 2
// 输出样例：
// 22

/*
状态表示f[i,j]
  集合：所有将第i堆石头到第j堆石头合并成一堆石头的合并方式
  属性：Min
状态计算：
  因为石子都是两堆两堆合并起来的，所以我们按照len从2到n来合并，先把长度为2的都合并起来，然后再根据长度为2的合并长度为3的，直到长度为n
  比如说，一堆石头有4个，那么首先len等于2，那么f[1,2],f[2,3],f[3,4]分别保存这两堆石头合并所需要代价的最小值
  然后len等于3，也就是要计算f[1,3]和f[2,4]，f[1,3]有两种情况，一种是f[1,2],f[3,3]，另一种是f[1,1],f[2,3]，通过上面len等于2求得的最小值来获取f[1,3]
  最后len等于4，有三种情况,f[1][2]和f[3,4]，f[1,1]和f[2,4]，f[1,3]和f[4,4]，这里要用到len为2和3，也就是说呢，随着len变大，len大的要用到len小的时候
  求得的f，根据它来获取最小值
最终f[1][n]就是答案，代表从第1堆石头到第n堆石头合并成一堆石头代价的最小值
*/
#include<iostream>
using namespace std;

const int N = 310;
int s[N], f[N][N];

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> s[i];
    for(int i = 1; i <= n; i++) s[i] += s[i - 1]; // 获取前缀和
    
    for(int len = 2; len <= n; len++) // len等于1时，代价就是它自己，所以不需要记录
        for(int i = 1; i + len - 1 <= n; i++){ // 从第一个数开始，要保证右边界不能越界
            int l = i, r = i + len - 1; // l代表这个区间的左边界，r代表右边界
            f[l][r] = 1e9; // 先要把它初始化成一个较大的数，否则默认的0会比代价都小
            for(int k = l; k < r; k++) // k就代表了分界线，表示左边有1堆，左边有2堆......左边有k堆，k必须小于r，因为保证右边必须有一堆
                // 然后把这两堆的代价加起来，再加上它自身的代价，也就是l到r的所有石头总数，选择较小的那一个
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); 
        }
    cout << f[1][n] << endl; // f[1][n]就代表了从第1堆石头到第n堆石头合并成一堆石头代价的最小值
    return 0;
}