// 求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

// 例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。

// 如下图所示：

// 2411_1.jpg

// 输入格式
// 输入包含多组测试用例。

// 每组测试用例占一行，包含两个整数 N 和 M。

// 当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。

// 输出格式
// 每个测试用例输出一个结果，每个结果占一行。

// 数据范围
// 1≤N,M≤11
// 输入样例：
// 1 2
// 1 3
// 1 4
// 2 2
// 2 3
// 2 4
// 2 11
// 4 11
// 0 0
// 输出样例：
// 1
// 0
// 1
// 2
// 3
// 5
// 144
// 51205

/*
这是一道状态压缩DP问题，说实话这道题我觉得很难，翻了几篇别人的解析，再加上自己思考了很久才理解
它的想法是这样的，给了我一个N * M的棋盘，要问有多少种方案，只要得出有多少种横着放的方案就可以，因为如果一种方案横着放已经决定了，那么它竖着放也一定已经决定
了，因为只能都竖着放，没有别的选择
状态f[i][j]，i表示第i列，j表示这列的方案数，也就是所有的可能，f[i][j]表示已经前前i-1列摆好了，从第i-1列横着摆放了长方形，延伸到第i列，这个第i列所有的状态
就是j的所有方案，这个j表面上是一个十进制数，但是我们要把它想成二进制数，比如所这个棋盘是5*6，那么第i列就有2^5种方案，如果第i行第j列有延伸出来的，就用1表示，
如果没有，就用0表示，比如说10010这一种方案，意思就是第i列的第1、4行有从第i-1列延伸出来的，第2、3、5行没有从第i-1列延伸出来的，用十进制表示就是f[i][18]
*/
#include<cstring>
#include<iostream>
using namespace std;

const int N = 12, M = 1 << N;

int n, m;
long long f[N][M]; // 一维用N表示一共有多少列，二维表示有多少种方案
bool st[M]; // st对应f[N][M]的某一种方案是否成立，如果第i列和第i-1列有冲突，或者第i列有奇数个连续的0，那么就是不成立的，设置成false，否则就是true

int main(){
    while(cin >> n >> m, n || m){ // 因为输入0 0表示退出，所以只要当n和m不都为0，那么就可以继续
        memset(f, 0, sizeof f); // 先把所有方案数都重置成0
        for(int i = 0; i < 1 << n; i++){ // 枚举所有方案数
            st[i] = true; // 先把这个方案默认设置成true，如果后面有不成立的，就再改成false即可
            int cnt = 0; // 这个用来记录连续的0的个数
            for(int j = 0; j < n; j++){ // 因为棋盘一共有n行，所以每一种方案的二进制用n个数来表示
                if(i >> j & 1){ // 这个是从右往左进行，如果碰到了1
                    if(cnt & 1){ // 如果当前cnt的个数是奇数，那么它与上1，结果一定就是非0，如果cnt是偶数，与上1就是0，表示目前为止还是成立的
                        st[i] = false; // 但是如果判断为true，那么表示这个方案是不成立的，把st[i]设置成false，直接跳出循环
                        break;
                    }
                    cnt = 0; // 如果遇上了1，但是此时cnt偶数，没有冲突，所以把cnt重置成0，继续往后面看
                }else cnt++; // 如果这个数不是1，就让cnt自增，表示0个个数增加
            }
            if(cnt & 1) st[i] = false; // 这个只为了判断最后一段连续的0的个数是否为奇数，比如说10010，前两个0连续，但是最后一个0只有一个，所以不成立
        }
        f[0][0] = 1; // 回归定义，f[0][0]表示前-1列都已经摆好了，第-1列横着摆放长方形，延伸到第0列的方案只有一种，那就是没有延伸过来，因为压根就没有
                     // 第-1列，所以第0列只有竖着放这一种方式，所以把f[0][0]设置为1
        for(int i = 1; i <= m; i++) // 第一个循环是枚举每一列
            for(int j = 0; j < 1 << n; j++) // 第二个循环是枚举第i列的所有方案
                for(int k = 0; k < 1 << n; k++) // 第三个循环是枚举所有第i-1列的方案
                    if((j & k) == 0 && st[j | k])  // 这里 j & k 一定要加括号，具体原因不清楚，可能是因为字符的顺序吧
                    // j & k如果等于0，那么就没有重叠，但是如果不为0，那么就会有重叠，j & k 和 j | k 都是要看成二进制，j | k就是看看这种方案连续0的
                    // 个数是不是偶数，如果是偶数，那对应的st肯定是true
                        f[i][j] += f[i - 1][k]; // 第i列的j这种方案加上第i-1列的k这种方案的个数
        // 因为题目给的是从1-m，但是我们把它映射到了0~m-1，所以实质上是没有第m列的，但是最后输出f[m][0]表示前m-1列都摆放好了，第m-1列延伸到第m列的方案是
        // 0的时候一共有多少种方案
        cout << f[m][0] << endl;
    }
    return 0;
}