// 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

// 第 i 件物品的体积是 vi，价值是 wi。

// 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
// 输出最大价值。

// 输入格式
// 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

// 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

// 输出格式
// 输出一个整数，表示最大价值。

// 数据范围
// 0<N,V≤1000
// 0<vi,wi≤1000
// 输入样例
// 4 5
// 1 2
// 2 4
// 3 4
// 4 5
// 输出样例：
// 8

/*
01背包问题是在背包容积的范围内尽可能选择价值最多的物品，每件物品只能拿一次
思想？
状态表示：用一个数组f[i][j]来保存所有选法，规定f[i][j]表示只能从前i个物品中选择，并且总体积是要小于等于j的，按照这个方式做，比如说题目给出n个物品，
体积最大是m，那么答案就是f[n][m]表示从前n个物品中选择价值最多的物品，保证它的体积在m范围内
那么要怎么实现呢？
状态计算：可以把f[i][j]分成两块，一块表示不选择第i个物品，一块表示选择第i个物品，最终的结果就取二者大的那一个
(1)、如果不选择第i个物品，那么实质上就是从第1~i-1个物品中选择，那么也就表示成了f[i-1][j]
(2)、如果选择第i个物品，因为直接求不好，我们可以曲线救国，换一种思考方式，因为第i个物品是必选的，所以实质上也可以分成两部分
    一部分是选择了第i个物品，它的价值是w[i]
    一部分是在选择了第i个物品的基础上在1~i-1个物品中选择，容积不能超过j-v[i]
    最终将二者加起来就是结果了，表示成 f[i-1][j-v[i]] + w[i]，但是是有限制的，j必须大于v[i]，因为容量必须大于第i个物品的体积，否则就不能选择第i个物品
上面二者要选择大的那一个保存到f[i][j]
*/
// 方式一：二维数组
// #include<iostream>
// using namespace std;

// const int N = 1010;
// int n, m; // n表示物品的数目，m表示背包的容积
// int v[N], w[N]; // v数组保存每个物品的体积，w数组保存每个物品的价值
// int f[N][N]; // f二维数组保存在前i个物品中选择价值最高的物品，保证容积小于等于j

// int main(){
//     cin >> n >> m;
//     for(int i = 1; i <= n; i++) cin >> v[i] >> w[i]; // 从下标为1开始保存物品
//     // 正常来说应该是f[0-n][0-m]，但是当i等于0的时候，表示选择前0个物品，那么保存的肯定是0，而把数组在全局定义，自动重置成了0，所以不需要进行操作
//     for(int i = 1; i <= n; i++)
//         for(int j = 0; j <= m; j++){ 
//             f[i][j] = f[i - 1][j]; // 不选择第i个物品这种选择是肯定存在的
//             if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); // 如果背包容量是大于第i个物品的体积的，那么就选择二者较大的那一种选择方式
//         }
//     cout << f[n][m] << endl; // 表示从前n个物品中选择价值最高的，并且体积不超过m
//     return 0;
// }

// 方式二：一维数组
/*
使用滚动数组， 外层循环是从第一个物品开始，每一次循环更新j容积下的最优解，那么我们可以用一位数组只保存容积从1到m的最优解，每次保存到数组里面的必须是比
上一层循环更优的解才能保存，所以f[j]每次保存f[j]和f[j-m[i]] + w[i]中较大的那一个
*/
#include<iostream>
using namespace std;

const int N = 1010;
int v[N], w[N];
int f[N];

int main(){
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++){
        for(int j = m; j >= v[i]; j--){ 
        // 注意，这里j必须从大的开始，因为这里的f[j-v[i]]相当于二维数组时的f[i-1][j-v[i]]，如果从小到大开始可能会把i-1变成i，而从大往小可以保证每一个
        // f[j-v[i]]都是第i-1次循环的结果
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}